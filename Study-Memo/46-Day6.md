# BDMI学习

每周最少一次更新有关python, MySQL 和 Tensorflow的学习历程。

##### 22 April 2020

buffer 是内存中一段存放临时数据的空间

page 内存或外村中一段连续的，固定大小的数组

file 由多个page组成

一个page大小一般为若干个kb。	

如果数据量不大，那么可以在内存中使用传统的排序算法进行排序，可是如果数据量很大(若干个TB)，那么排序可能就需要在使用外村为主存储器的情况下进行。

今天要研究的是文件(files)的多路归并排序。

这个排序算法是用来对无法直接放入内存进行排序的文件进行排序的算法。

第一步，对文件进行若干次run,每次run都将一部分的文件的pages放入内存排序，然后再写入原文件。

接下来就根据内存缓冲区的page数量B+1进行B路归并排序。也就是说，当缓冲区中有3个pages，那么这个缓冲区可以对两个run的结果进行外部归并排序。

两个run中各加载一个page，设一个page中有k个数，那么从2个page各选出共1个page（一共2k个数），然后从选出来的这些page的数中再选出k个最小的数，写到最终的文件里。剩余的数继续放在缓冲区里，刚刚从被提取page的最大值较小的文件中继续读入下一个page，以此类推。

如果拥有4个buffer pages，那么可以同时对3个文件进行排序。实际上，若假设IO操作复杂度大于比较复杂度，则多路归并排序的复杂度为：

![image-20200423021844222](C:\Users\NG JU PING\AppData\Roaming\Typora\typora-user-images\image-20200423021844222.png)

其中N为总数字数量，B+1为buffer pages数量。

一般上，除了增加buffer pages进行优化，也可以通过repacking技术进行优化！

这个技术对部分排好序的文件能有效进行排序，最好情况一次情空，最坏情况B+1个runs，比原本的复杂度还要低。

这个执行步骤如下：

首先加载B个pages进到长度为B+1的内存缓冲区。选择最小的k个数组成一个可以写入到新文件的page，然后把这个page写入到新文件，并更新一个counter m，记录写到文件里那个page中k个数的最大值。注意：如果当前buffer中所有数都小于m，那这些值都不被考虑到写入新文件的page里，我们形容这些数为frozen values。

当buffer被这些frozen values填满，那么就把这些buffer pages的数排序后和那个被之前顺序填入pages的文件中的pages进行B路归并排序。





